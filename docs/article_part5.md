# Ненормальные непотребства, трюки, хаки и алгоритмы на C

Доброго времени суток, господа и дамы! Иногда у некоторых людей возникает желание заняться откровенным непотребством в программировании — то, что не несет практической пользы напрямую, но помогает развлечься. И я — не исключение. В этой статье я хочу рассказать вам о лайфхаках, трюках (магических и не очень), алгоритмах на языке C!

Идея написать эту статью зародилась из [моего поста](https://habr.com/ru/post/929236/), после него я начал серию статей, которая раскрывала много интересных моментов - от математических алгоритмов и оптимизации до ГПСЧ.

Увидев, что многим понравилась, я решил продолжить данную серию статей. Части независимы друг от друга, в каждой статье я прикладываю бенчмарки и графики.

В этой статье будет еще порция свежих хаков, фанов, трюков, еще больше магии и скорости!

Всех, кто заинтересовался — прошу под кат.

---

## Содержание

Вы можете читать статьи в любом порядке, они независимы друг от друга:

+ [«Математика, биты, магия и немного ненормального программирования на C»](https://habr.com/ru/companies/timeweb/articles/935728/)
+ [«Фокусы, хаки, магия и прочее ненормальное программирование на C»](https://habr.com/ru/companies/timeweb/articles/967678/)
+ [«Тёмная сторона Си: трюки, хаки, магия и алгоритмы»](https://habr.com/ru/companies/timeweb/articles/970910/)
+ [«Изящные, быстрые и удивительные алгоритмы на C»](https://habr.com/ru/companies/timeweb/articles/971528/)

---

Наступила юбилейная, пятая часть серии статей.

# Алгоритм Флетчера-32
Данный алгоритм позволяет вычислять 32-битную контрольную сумму. Разработан Джоном Флетчером из Лаборатории Лоуренса Ливермора в конце 1970-х годов.

Алгоритм включает разделение слова двоичных данных на короткие «блоки» битов и вычисление модульной суммы этих блоков. Процесс:

1. Инициализировать две суммы — sum1 и sum2, — в ноль.
2. Для каждого 16-битного слова (2 байта) в входных данных:
 + Добавить значение слова к sum1, взяв результат по модулю 65 535.
 + Добавить новое значение sum1 ко второй сумме, взяв результат по модулю 65 535.
3. Окончательная 32-битная контрольная сумма формируется путём объединения sum2 (наиболее значащих 16 бит) и sum1 (наименее значащих 16 бит). Результат: Result = (sum2 << 16) | sum1.

Среди особенностей можно выделить что он чувствителен к порядку блоков, а также алгоритм не являестя криптографически безопасным - он предназначается для проверки целостности данных, а не для проверки подлинности.

# Заключение

Спасибо за прочтение статьи! Я надеюсь, вы узнали что‑то новенькое, или может, какой‑нибудь трюк натолкнул вас на другой интересный алгоритм. Если нашли нюанс в самой статье — пишите в комментарии.

Если вам понравился изложенный материал, могу предложить вам подписаться на [мой блог в телеграме](https://t.me/hex_warehouse). Если, конечно, вам статья понравилась и вы хотите видеть чуть больше.

Примеры работы кода вы можете увидеть в [моем репозитории The Art Of Fun C](https://github.com/alexeev-prog/theartoffun_c).
