# Ненормальные непотребства, трюки, хаки и алгоритмы на C

Доброго времени суток, господа и дамы! Иногда у некоторых людей возникает желание заняться откровенным непотребством в программировании — то, что не несет практической пользы напрямую, но помогает развлечься. И я — не исключение. В этой статье я хочу рассказать вам о лайфхаках, трюках (магических и не очень), алгоритмах на языке C!

Идея написать эту статью зародилась из [моего поста](https://habr.com/ru/post/929236/), после него я начал серию статей, которая раскрывала много интересных моментов - от математических алгоритмов и оптимизации до ГПСЧ.

Увидев, что многим понравилась, я решил продолжить данную серию статей. Части независимы друг от друга, в каждой статье я прикладываю бенчмарки и графики.

В этой статье будет еще порция свежих хаков, фанов, трюков, еще больше магии и скорости!

Всех, кто заинтересовался — прошу под кат.

---

## Содержание

Вы можете читать статьи в любом порядке, они независимы друг от друга:

+ [«Математика, биты, магия и немного ненормального программирования на C»](https://habr.com/ru/companies/timeweb/articles/935728/)
+ [«Фокусы, хаки, магия и прочее ненормальное программирование на C»](https://habr.com/ru/companies/timeweb/articles/967678/)
+ [«Тёмная сторона Си: трюки, хаки, магия и алгоритмы»](https://habr.com/ru/companies/timeweb/articles/970910/)
+ [«Изящные, быстрые и удивительные алгоритмы на C»](https://habr.com/ru/companies/timeweb/articles/971528/)

---

Наступила юбилейная, пятая часть серии статей.

# Алгоритм Флетчера-32
Данный алгоритм позволяет вычислять 32-битную контрольную сумму. Разработан Джоном Флетчером из Лаборатории Лоуренса Ливермора в конце 1970-х годов.

Алгоритм включает разделение слова двоичных данных на короткие «блоки» битов и вычисление модульной суммы этих блоков. Процесс:

1. Инициализировать две суммы — sum1 и sum2, — в ноль.
2. Для каждого 16-битного слова (2 байта) в входных данных:
 + Добавить значение слова к sum1, взяв результат по модулю 65 535.
 + Добавить новое значение sum1 ко второй сумме, взяв результат по модулю 65 535.
3. Окончательная 32-битная контрольная сумма формируется путём объединения sum2 (наиболее значащих 16 бит) и sum1 (наименее значащих 16 бит). Результат: Result = (sum2 << 16) | sum1.

Среди особенностей можно выделить что он чувствителен к порядку блоков, а также алгоритм не являестя криптографически безопасным - он предназначается для проверки целостности данных, а не для проверки подлинности.

Давайте перейдем к самой сишной реализации:

```c
uint32_t fletcher32(const uint16_t* data, size_t len) {
    uint32_t sum1 = 0xffff, sum2 = 0xffff;

    while (len) {
        size_t tlen = len > 360 ? 360 : len;
        len -= tlen;

        do {
            sum1 += *data++;
            sum2 += sum1;
        } while (--tlen);

        sum1 = (sum1 & 0xffff) + (sum1 >> 16);
        sum2 = (sum2 & 0xffff) + (sum2 >> 16);
    }

    sum1 = (sum1 & 0xffff) + (sum1 >> 16);
    sum2 = (sum2 & 0xffff) + (sum2 >> 16);
    return sum2 << 16 | sum1;
}
```

Алгоритм работает с массивом 16-битных слов. В основе лежат две аккумулирующие суммы, инициализированные значением 0xffff. На каждом шаге основного цикла к sum1 прибавляется очередное 16 битное значение их входного массива, а к sum2 прибавляется текущее значение sum1. Это создает зависимость между всеми элементами данных.

Ключевая особенность реализации - обработка данных блоками по 360 элементов. Это предотвращает возможное переполнение при больших объемах данных. После обработки каждого блока выполняется операция модульной редукции: младшие 16 бит складываются со старшими 16 битами, что равно вычислению остатка от деления на 2^16.

После обработки всех данных выполняется финальная редукция сумм, и результат формируется как объединение sum2 (в старших 16 битах) и sum1 (в младших 16 битах). Такой подход обеспечивает хорошее обнаружение различных типов ошибок, включая перестановки соседних слов.

Ниже я предоставил функцию для того чтобы получать контрольную сумму строки:

```c
uint32_t fletcher32_string(const char* str) {
    size_t len = strlen(str);
    size_t padded_len = (len + 1) / 2;
    uint16_t* data = (uint16_t*)str;
    return fletcher32(data, padded_len);
}
```

Данный алгоритм в итоге корретно работает, и может показывать следующий результат:

```
Строка: "Fletcher32 checksum test"
Результат: 0x646d915c
```

# ГПСЧ TinyMT32
TinyMT — генератор псевдослучайных чисел, лёгкий вариант Mersenne Twister (MT). Представлен в 2011 году Муцуо Сайто и Макото Мацумото. Основное преимущество TinyMT32 — маленький размер внутреннего состояния. И так-же как большинство ГПСЧ он не подходит для криптографии.

Структура `tinymt32_t` содержит внутренее состояние генератора в виде массива из четырех 32-битных целых чисел.

Кроме того, этот ГПСЧ требует сначала инициализации себя, функция `tinymt32_init` устанавливает начальное состояние на основе переданного seed. Первый элемент состояния инициализируется значением сида, остальные - константами. Затем выполняется 8-раундная инициализация с обновлением состояния. Операции сдвига и XOR обеспечивают хорошее распространение сида по всему состоянию.

А вот сама функция генерации выполняет одно преобразование состояния и возвращает псевдослучайное число. Сначала вычисляется промежуточное значение x путём комбинации битов из трёх элементов состояния с использованием маски 0x7FFFFFFF и операции XOR. Затем это значение сдвигается влево и снова применяется XOR. Далее выполняется циклический сдвиг элементов состояния, где первые три элемента сдвигаются, а последний вычисляется на основе x и предыдущего состояния. Возвращаемым значением становится новый вычисленный элемент state[3].

```c
typedef struct {
    uint32_t state[4];
} tinymt32_t;

void tinymt32_init(tinymt32_t *tmt, uint32_t seed) {
    tmt->state[0] = seed;
    tmt->state[1] = 0x8f7011ee;
    tmt->state[2] = 0xfc78ff1f;
    tmt->state[3] = 0x3793fdff;

    for (int i = 1; i < 8; i++) {
        tmt->state[i & 3] ^= i + 1812433253 *
            (tmt->state[(i-1) & 3] ^ (tmt->state[(i-1) & 3] >> 30));
    }
}

uint32_t tinymt32_generate(tinymt32_t *tmt) {
    uint32_t x = (tmt->state[0] & 0x7fffffff) ^ tmt->state[1] ^ tmt->state[2];
    x ^= x << 1;
    tmt->state[0] = tmt->state[1];
    tmt->state[1] = tmt->state[2];
    tmt->state[2] = tmt->state[3] ^ (x >> 1);
    tmt->state[3] = x;
    return tmt->state[3];
}
```

Об этом алгоритме можно прочитать на [странице RFC 8682](https://datatracker.ietf.org/doc/html/rfc8682).

# Хеш-функция FNV-1a
Давайте перейдем к теме хеш-функций. FNV-1a (Fowler–Noll–Vo) - одна из них. Она не подходит для криптографии, но позволяет быстро вычислять значения и подходит для хеш-таблиц.

Алгоритм начинается с инициализации хеш-значения начальным числом 2166136261. Затем для каждого байта входных данных выполняется две операции: операция XOR текущего хеша со значением байта, за которой следует умножение на 16777619.

```c
uint32_t fnv1a_hash(const void *data, size_t len) {
    const uint8_t *bytes = (const uint8_t*)data;
    uint32_t hash = 2166136261u;

    for (size_t i = 0; i < len; i++) {
        hash ^= bytes[i];
        hash *= 16777619u;
    }
    return hash;
}
```

# Заключение

Спасибо за прочтение статьи! Я надеюсь, вы узнали что‑то новенькое, или может, какой‑нибудь трюк натолкнул вас на другой интересный алгоритм. Если нашли нюанс в самой статье — пишите в комментарии.

Если вам понравился изложенный материал, могу предложить вам подписаться на [мой блог в телеграме](https://t.me/hex_warehouse). Если, конечно, вам статья понравилась и вы хотите видеть чуть больше.

Примеры работы кода вы можете увидеть в [моем репозитории The Art Of Fun C](https://github.com/alexeev-prog/theartoffun_c).
