# Фибоначчи, магия и немного ненормального программирование на C
Доброго времени суток, господа хабровчане! Иногда у некоторых людей возникает желание заняться откровенным непотребством в программировании — то, что не несет практической пользы напрямую, но помогает развлечься. И я — не исключение. В этой статье я хочу рассказать вам о лайфхаках, трюках (магических и не очень), алгоритмах на языке C!

Идея написать эту статью зародилась из [моего поста](https://habr.com/ru/post/929236/), где я рассказал о том, что черех последовательность Фибоначчи можно конвертировать мили в километры с небольшой погрешностью (и написал конвертер на C). Увидев, что народу понравилась, я задумался, почему бы не изучить еще какие-нибудь трюки, заодно практикуясь в программировании на C?

Всех, кто заинтересовался — прошу под кат. Конвертеры, интересные макросы, алгоритмы, задачки, и прочее прочее прочее.

---

Раз я уже начал рассказывать о Фибоначчи, немного процитирую свой пост:

> Последовательность Фибоначчи может конвертировать мили в километры с небольшой погрешностью. 5 миль ≈ 8 км (5 и 8 — числа Фибоначчи). Реальность: 5 миль = 8.04672 км.
> Почему? 1 миля = 1.609344 километра (точное значение). Золотое сечение (φ) ≈ 1.618034
> Погрешность возникает потому что отношение Fₙ₊₁ / Fₙ стремится к φ ≈ 1.618034, а точное соотношение миля/км = 1.609344.
> Относительная погрешность: (1.618034 — 1.609344) / 1.609344 * 100% ≈ 0.54%.

Давайте посмотрим, как реализовать такой конвертер на C.

Вот допустим есть такая функция:

```cpp
uint64_t fibonacci(int num) {
    if (num < 0)
        return 0;
    if (num == 0)
        return 0;

    uint64_t a = 0;
    uint64_t b = 1;

    if (num == 1)
        return b;

    for (int i = 2; i <= num; i++) {
        uint64_t next = a + b;
        a = b;
        b = next;
    }

    return b;
}
```

Работаем через цикл. Допустим мы хотим узнать сколько километров в 5 милях. Передаем как аргумент num+1 чтобы узнать следующее число Фибоначчи и получаем 8 километров.

Также, можно сделать вычисление на основе золотого сечения — ибо оно также связано с последовательностью Фибоначчи.

```cpp
float fib_golden_ratio(float miles) {
    const double PHI = (1.0 + sqrt(5.0)) / 2.0;

    if (miles < 1e-5) {
        return 0.0F;
    }

    double n = log(miles * sqrt(5.0)) / log(PHI);
    int k = (int)floor(n);

    double Fk = (pow(PHI, k) - pow(-PHI, -k)) / sqrt(5.0);
    double Fk1 = (pow(PHI, k + 1) - pow(-PHI, -k - 1)) / sqrt(5.0);
    double Fk2 = (pow(PHI, k + 2) - pow(-PHI, -k - 2)) / sqrt(5.0);

    if (Fk1 - Fk < DBL_EPSILON) {
        return basic_miles2km(miles);
    }

    return Fk1 + ((miles - Fk) * ((float)(Fk2 - Fk1) / (Fk1 - Fk)));
}
```

На основе числа φ ((1 + √5) / 2) мы также можем конвертировать мили в километры.

Переменная n здесь — это индекс числа Фибоначчи, соответствующий значению miles, основанный на свойстве, что F(n) ≈ φ^n / √5. Используется логарифмическая функция, чтобы найти n, а затем округляется до ближайшего меньшего целого числа k.

Переменные Fk, Fk1, Fk2 — это три последовательных числа Фибоначчи, вычисляемые через формулы Бине для чисел Фибоначчи: F(n) = (φ^n — (1 — φ)^n) / √5.

> Формула Бине — это явная формула для нахождения n-го числа Фибоначчи без рекурсивного вычисления. Она названа в честь французского математика, который её открыл. Формула Бине позволяет вычислять числа Фибоначчи за константное время (O(1)), тогда как рекурсивный способ может занять экспоненциальное время. Это делает формулу Бине очень полезной в вычислениях, связанных с последовательностями Фибоначчи.

Если разница между F(k+1) и F(k) меньше DBL_EPSILON, это означает что числа слишком близки друг к другу, и функция вместо вычисления дальнейшего значения просто вызывает функцию basic_miles2km:

```cpp
float basic_miles2km(float miles) {
    return miles * 1.609344f;
}
```

И в конце идет интерполяция для нахождения результативного числа Фибоначчи: `return Fk1 + ((miles - Fk) * ((float)(Fk2 - Fk1) / (Fk1 - Fk)));`. Если предыдущие условия не выполнены, функция выполняет линейную интерполяцию, чтобы получить более точное значение числа Фибоначчи, основываясь на значении miles. Но эта функция при больших n может накапливать ошибки.

Перейдем к другой похожей реализации:

```c
float fib_interpolate(float miles) {
    if (miles < 5.0F) {
        return basic_miles2km(miles);
    }

    uint64_t prev_mile = 0;
    uint64_t prev_km = 1;
    uint64_t curr_mile = 1;
    uint64_t curr_km = 2;

    while (curr_mile <= miles) {
        prev_mile = curr_mile;
        prev_km = curr_km;

        curr_mile = prev_km;
        curr_km = prev_mile + prev_km;

        if (curr_km < prev_km || curr_mile < prev_mile) {
            break;
        }
    }

    return prev_km + ((miles - prev_mile) * ((float)(curr_km - prev_km) / (curr_mile - prev_mile)));
}
```

В функции объявлены переменные, использующие 64-битные целые числа без знака для хранения значений миль и километров, где prev_mile и prev_km хранят предыдущие расстояния, а curr_mile и curr_km — текущие. Затем начинается основной цикл, который будет выполняться до тех пор, пока текущее значение миль (curr_mile) меньше или равно переданному значению miles. На каждой итерации цикла обновляются значения переменных через стандартные формулы Фибоначчи, что соответствует генерации последовательности (при этом текущее значение миль обновляется на значение предшествующего километра, а километры берут значение суммы двух предыдущих).

Чтобы предотвратить переполнение переменных, в теле цикла также содержится проверка: если новое значение километров или миль становится меньше предыдущего, цикл прерывается. Это условие служит защитой от некорректных данных и потенциальных ошибок исполнения.

После завершения цикла производится интерполяция для получения значения километров на основе предшествующих значений, где используется линейная интерполяция. Этот расчет позволяет более точно находить значение, чем простое преобразование, основанное только на числах Фибоначчи. Тем не менее, такая интерполяция может быть недостаточно точной для больших значений миль, что ослабляет точность результата в зависимости от диапазона входных параметров.

Временная сложность функции `fib_interpolate` — O(n), где n — это позиция в последовательности Фибоначчи.

Более подробно весь код можете просмотреть в [репозитории fib_miles2km](https://github.com/alexeev-prog/fib_miles2km) или прямо в репозитории-сборнике для этой статьи [The Art Of Fun C](https://github.com/alexeev-prog/theartoffun_c).

## Бинарное возведение в степень
Выше мы использовали формулу Бине, которая требовала операцию возведения в степень. Давайте попробуем импортозаместить стандартный `pow` нашим алгоритмом, а точнее — бинарным возведением в степень. Сложность — O(log n).

Широко известный алгоритм для возведения любого числа в целую степень с абсолютной точностью. Принцип действия прост: есть целая степень e, чтобы получить число b в этой степени нужно возвести это число во все степени 1, 2, 4, … 2n (в коде этому соответствует b *= b), каждый раз сдвигая биты e вправо (e >>= 1) пока оно не равно 0 и тогда, когда последний бит e не равен нулю ((e & 1) != 0), домножать результат v на полученное b. Этот метод позволяет возвести число в целую степень за логарифмическое время, что особенно важно при работе с большими числами.

Возьмём 2⁵. Вместо 2×2×2×2×2 мы представляем 5 в двоичном виде (101) и идем по битам справа налево. Первый бит (1) равен 2, второй бит (0) равен 2 в квадрате, и в последнем третьем биту (1) результат (2) умножаем на текущее значение (4²=16) → 32.

Технически, при каждом проходе цикла, мы проверяем младший бит степени e. Если этот бит равен 1 (e & 1 != 0), мы умножаем текущий результат v на основание b. После этого мы умножаем b на само себя (квадрат), что соответствует следующей степени двоичного представления. Уменьшая e с помощью побитового сдвига вправо, мы продолжаем цикл, пока e не достигает нуля, в результате чего получаем финальный результат.

```cpp
double binary_pow(double b, unsigned long long e) {
    double v = 1.0;
    while(e != 0) {
            if((e & 1) != 0) {
                    v *= b;
            }
            b *= b;
            e >>= 1;
    }
    return v;
}
```

И при выполнении мы можем получить 10.00^2.00 = 100.00, 10.50^2.00 = 110.25. Но если экспонента не целое число, то данный способ не подойдет (10.50^2.50 вычисляется как 110.25). Так что важно отметить, что этот алгоритм применим только к целым числам.

## Генератор псевдослучайных чисел Xorshift
Давайте перейдем к не менее интересному алгоритму — генерации псевдослучайных чисел. Давайте попробуем реализовать свой генератор таких чисел на основе Xorshift. Xorshift — это семейство генераторов псевдослучайных чисел, которые используют операцию сдвига и исключающего ИЛИ (XOR). Они просты в реализации, очень быстры и дают достаточно хорошие результаты для многих задач.

```cpp
uint64_t xorshift64(uint64_t *state) {
    uint64_t x = *state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    *state = x;
    return x;
}
```

Данный алгоритм работает так:

1. Сдвиг влево + XOR (x << 13): «Размазывает» биты в старшие разряды. Операция XOR смешивает оригинальные биты с изменёнными.
2. Сдвиг вправо + XOR (x >> 7): Работает как «обратный» шаг — компенсирует предыдущий сдвиг, добавляя нелинейность.
3. Сдвиг влево + XOR (x << 17): Фиксирует результат и обеспечивает полное перемешивание битов. Числа 13, 7, 17 подобраны экспериментально для оптимального качества.

Ключевое преимущество — всего 3 операции на число, что делает алгоритм невероятно быстрым — O(1) на генерацию числа.

Для генерации state давайте напишем функцию для получения таймстемпа в микросекундах:

```cpp
uint64_t get_seed() {
    struct timeval tv;
    gettimeofday(&tv,NULL);
    return tv.tv_sec*(uint64_t)1000000+tv.tv_usec;
}
```

Кроме того, давайте для полноты реализуем функции для генерации плавающего числа и генерацию по диапазону:

```cpp
double rand_double(uint64_t *state) {
    return (xorshift64(state) >> 11) * (1.0 / (UINT64_C(1) << 53));
}
```

Данная функция возвратит число в диапазоне `[0.0, 1.0)`. Сначала генерируем 64-битное число и сдвигаем на 11 бит вправо. Это нужно чтобы отбросить младшие биты. В итоге остается 53 бита. После вычисляем `1.0 / (UINT64_C(1) << 53)` (`UINT64_C(1) << 53 = 2⁵³ = 9,007,199,254,740,992.`). В итоге получаем минимальный шаг между числами double: 1.0 / 2⁵³ ≈ 1.110223e-16. И под конец перемножаем 53 бита на этот самый шаг.

> Если вы задались вопросом, почему именно 53 бита — то в стандарте IEEE 754 тип double имеет 53 бита мантиссы. Структура числа двойной точности: знак — 1 бит, порядок — 11 бит, мантисса — 52+1 бит.

И генерация случайного числа в диапазоне:

```cpp
uint64_t rand_range(uint64_t *state, uint64_t min, uint64_t max) {
    return min + xorshift64(state) % (max - min + 1);
}
```

Он будет уже попроще: xorshift64(state) даёт случайное число. Через `% (max — min + 1)` узнаем остаток от деления на длину диапазона, и прибавляем к итоговому числу min.

И в итоге мы можем получить такие результаты работы:

```bash
xorshift64 random number: 8549869788877919663 # Случайное число
xorshift64 random num from 10 to 100: 72 # Случайное число в диапазоне
xorshift64 double random number: 0.461347 # Случайное дробное число
```

## Быстрый обратный квадратный корень из Quake III
В 2005 году id Software опубликовала под лицензией GPL-2 исходный код своей игры 1999 года Quake III Arena. В файле [code/game/q_math.c](https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/q_math.c#L552) есть функция для вычисления обратного квадратного корня числа, которая на первый взгляд выглядит очень любопытным алгоритмом:

```cpp
float Q_rsqrt( float number )
{
	long i;
	float x2, y;
	const float threehalfs = 1.5F;

	x2 = number * 0.5F;
	y  = number;
	i  = * ( long * ) &y;						// evil floating point bit level hacking
	i  = 0x5f3759df - ( i >> 1 );               // what the fuck?
	y  = * ( float * ) &i;
	y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
//	y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed

#ifndef Q3_VM
#ifdef __linux__
	assert( !isnan(y) ); // bk010122 - FPE?
#endif
#endif
	return y;
}
```

Как же работает этот алгоритм? Он выполняется в два этапа:

1. Получение грубой аппроксимации y обратного квадратного корня нужного числа number:

```cpp
y  = number;
i  = * ( long * ) &y;
i  = 0x5f3759df - ( i >> 1 );
y  = * ( float * ) &i;
```

2. Уточнение аппроксимации при помощи одного шага метода Ньютона-Рафсона (NR):

```cpp
const float threehalfs = 1.5F;
x2 = number * 0.5F;
y  = y * ( threehalfs - ( x2 * y * y ) );
```

Алгоритм принимает 32-битное число с плавающей запятой (одинарной точности в формате IEEE 754) в качестве исходных данных. Точность алгоритма — менее 0,2% в меньшую сторону и никогда — в большую. Это не хватает для настоящих численных расчётов, но достаточно для трёхмерной графики.

Подробнее о работе данной функции можно прочитать в [этой статье](https://habr.com/ru/articles/730872/) и на [странице в википедии](https://en.wikipedia.org/wiki/Fast_inverse_square_root).

Для проверки можно немного изменить код:

```cpp
float Q_rsqrt(float number) {
    int32_t i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( int32_t* ) &y;
    i  = 0x5f3759df - ( i >> 1 );
    y  = * ( float* ) &i;
    y  = y * ( threehalfs - ( x2 * y * y ) );
    return y;
}
```

И мы должны получить почти-что правильный результат: `Q_rsqrt(25.00) = 0.199690`. Для точности можно добавить еще одну итерацию Ньютона `y = y * (threehalfs — (x2 * y * y));`: `Q_rsqrt(25.00) = 0.199999`.

# Заключение
Спасибо за прочтение статьи! Я надеюсь вы узнали что-то новенькое, или может какой-нибудь трюк натолкнул вас на другой интересный алгоритм. Если нашли нюанс в самой статье — пишите в комментарии. Возможно я продолжу серию таких статей на тему трюков на разных языках программирования.

Если вам понравился изложенный материал, могу предложить вам подписаться на [мой блог в телеграме](https://t.me/hex_warehouse). Если, конечно, вам статья понравилась и вы хотите видеть чуть больше.

## Источники

 - [alordash; «Ускоряем pow»](https://habr.com/ru/articles/584662/)
 - [Jorenar, перевод Sivchenko_translate; «Некоторые малоизвестные фичи, фокусы и причуды языка C»](https://habr.com/ru/articles/847996/)
 - [Представление вещественных чисел](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB)
 - [Noah Hellman, перевод PatientZero; «Полезен ли сегодня быстрый обратный квадратный корень из Quake III?»](https://habr.com/ru/articles/730872/)
