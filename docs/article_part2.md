# Фокусы, хаки, магия и прочее ненормальное программирование на C
Доброго времени суток, господа и дамы! Иногда у некоторых людей возникает желание заняться откровенным непотребством в программировании — то, что не несет практической пользы напрямую, но помогает развлечься. И я — не исключение. В этой статье я хочу рассказать вам о лайфхаках, трюках (магических и не очень), алгоритмах на языке C!

Идея написать эту статью зародилась из [моего поста](https://habr.com/ru/post/929236/), после него я написал статью ["Математика, биты, магия и немного ненормального программирования на C"](https://habr.com/ru/companies/timeweb/articles/935728/), которая раскрывала много интересных моментов. Увидев, что многим понравилась, я задумался: почему бы не изучить еще какие-нибудь трюки, заодно практикуясь в программировании на C? В этой статье мы погрузимся глубже, и раскроем больше тем!

Всех, кто заинтересовался — прошу под кат.

---

В прошлой статье мы разработали следующее:

1. Алгоритмы псевдослучайной генерации: xorshift64, lehmer64, xoshiro256pp;
2. Алгоритмы Фибоначии и конвертаторы из милей в километры через них;
3. Алгоритмы быстрого обратного квадратного корня;
4. Алгоритм бинарного возведения в степень.

В этой статье я буду обозревать более глубокие и интересные трюки на языке C. Вам не обязательно читать первую часть, статьи в этой серии независимы друг от друга.

# Быстрое вычисление приближенного значения степени
В прошлой статье мне предложили разобрать [быстрое вычисление приближённого значения степени](https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/):

![](https://habrastorage.org/webt/t-/7a/rj/t-7arjmxif0_eqwz8sfwzshlwr8.png)

```c
inline double fastPow(double a, double b) {
    union {
        double d;
        int x[2];
    } u = { a };
    u.x[1] = (int)(b * (u.x[1] - 1072632447) + 1072632447);
    u.x[0] = 0;
    return u.d;
}
```

Данный алгоритм — это аппроксимация функции aᵇ, основанная на особенностях представления чисел с плавающей точкой в стандарте IEEE 754. Алгоритм использует тот факт, что возведение в степень можно выразить через экспоненту и логарифм: `aᵇ = exp(b × ln(a))`.

> В стандарте IEEE 754 тип double имеет 53 бита мантиссы. Структура числа двойной точности: знак — 1 бит, порядок — 11 бит, мантисса — 52+1 бит. Число представляется как `value = (-1)^sign × 2^(exponent - 1023) × (1 + mantissa/2^52)`

Ошибка составляет примерно 1-10% в зависимости от значений a и b. Алгоритм работает значительно быстрее стандартной функции pow().

Сама функция сначала разбирает double на целочисленные компоненты через union. В старших 32 битах содержится порядок числа, который примерно равен логарифму от a по второй степени. Потом идет преобразование `u.x[1]`, оно вычисляет u.x[1] - 1072632447 ≈ log₂a, затем умножение на b даёт b × log₂a, и в конце прибавление 1072632447 преобразует обратно в формат double. После преобразования идет обнуления младших 32 бит, устанавливая мантиссу в 0. Магическое число 1072632447 = 0x3FF00000 - 60701 — это смещённое представление логарифма.

Эта функция имеет свои ограничения: работает только для положительных a, зависит от порядка байтов и размера double.

Но у этого алгоритма есть более быстрая версия (из [этой статьи](https://habr.com/ru/articles/902040/)):

```c
float fastestPow(float a, float b) {
    union
    {
        float d;
        int x;
    } u = { a };

    u.x = (int)(b * (u.x - 1065353210) + 1065353210);

    return u.d;
}
```

Этот алгоритм работает за счёт манипуляции битовым представлением чисел float.

Число с плавающей точкой хранится в виде знака, порядка и мантиссы. Порядок по сути является логарифмом числа по основанию 2. Алгоритм использует это свойство: вычитание магического числа 1065353210 (которое соответствует числу 1.0 в битовом представлении) приближённо вычисляет логарифм исходного числа a. Умножение на b даёт b × log₂a. Затем добавление магического числа обратно преобразует результат в битовое представление числа с плавающей точкой.

Алгоритм быстрее предыдущего метода, но и менее точнее из-за использования float вместо double. По сути, float-версия делает только одну операцию с битовым представлением вместо двух и работает с данными вдвое меньшего размера, что даёт выигрыш в производительности за счёт потери точности по сравнению с double.

# Быстрое деление на 3
Эта функция заменяет медленное целочисленное деление на 3 быстрым умножением и сдвигом. Она использует магическую константу 0xAAAAAAAB, которая представляет собой приближение 2³²/3.

```c
uint32_t div3(uint32_t x) {
    return (uint32_t)(((uint64_t)x * 0xAAAAAAABULL) >> 32);
}
```

При умножении 32-битного числа на эту 64-битную константу старшие 32 бита результата содержат приблизительное значение x/3. Сдвиг вправо на 32 бита извлекает этот результат.

Такая оптимизация работает в 10-20 раз быстрее обычного деления, поскольку умножение и битовые операции выполняются процессором значительно быстрее операции деления. Этот метод широко используется компиляторами для оптимизации деления на известные константы.

# Алгоритм XOR Swap
Классический алгоритм, который позволяет обменивать значения двух переменных с помощью трех операций XOR без создания временной третьей.

```c
void xor_swap(int *a, int *b) {
    if (a != b) {
        *a ^= *b;
        *b ^= *a;
        *a ^= *b;
    }
}
```

Классический, но всегда впечатляющий новичков трюк: обмен значений двух переменных с помощью трёх операций XOR. Это демонстрирует симметрию и свойства операции XOR. Хотя на современных процессорах это часто медленнее, чем использование временной переменной (из-за параллелизма), трюк остаётся красивым и поучительным.

Первая операция сохраняет разность a и b в a, вторая используя исходное b и новое a получает исходное a и сохраняет в b, и последняя используя новое a и новое b получает исходное b и сохраняет в a.

    a = a ^ b (сохраняет "разность" a и b в a).

    b = b ^ a (используя исходное b и новое a, получает исходное a и сохраняет в b).

    a = a ^ b (используя новое a и новое b (которое равно исходному a), получает исходное b и сохраняет в a).

# Заключение
Спасибо за прочтение статьи! Я надеюсь вы узнали что-то новенькое, или может какой-нибудь трюк натолкнул вас на другой интересный алгоритм. Если нашли нюанс в самой статье — пишите в комментарии. Возможно я продолжу серию таких статей на тему трюков на разных языках программирования.

Если вам понравился изложенный материал, могу предложить вам подписаться на [мой блог в телеграме](https://t.me/hex_warehouse). Если, конечно, вам статья понравилась и вы хотите видеть чуть больше.

Примеры работы кода вы можете увидеть в [моем репозитории The Art Of Fun C](https://github.com/alexeev-prog/theartoffun_c).

## Источники

 + [Зажигаем миллиард цветов миллионом строк](https://habr.com/ru/articles/902040/)
