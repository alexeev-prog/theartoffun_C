# Изящные, быстрые и удивительные алгоритмы на C

Доброго времени суток, господа и дамы! Иногда у некоторых людей возникает желание заняться откровенным непотребством в программировании — то, что не несет практической пользы напрямую, но помогает развлечься. И я — не исключение. В этой статье я хочу рассказать вам о лайфхаках, трюках (магических и не очень), алгоритмах на языке C!

Идея написать эту статью зародилась из [моего поста](https://habr.com/ru/post/929236/), после него я написал статью [«Математика, биты, магия и немного ненормального программирования на C»](https://habr.com/ru/companies/timeweb/articles/935728/) и [«Фокусы, хаки, магия и прочее ненормальное программирование на C»](https://habr.com/ru/companies/timeweb/articles/967678/), которые раскрывали много интересных моментов. Увидев, что многим понравилась, я решил продолжить, чтобы узнать насколько глубоко кроличья нора!

В этой статье будет еще больше всевозможных генераторов псевдослучайных чисел, гонок за скоростью и производительностью, алгоритмов, хаков и трюков!

Всех, кто заинтересовался — прошу под кат.

---

## Содержание

Вы можете читать статьи в любом порядке, они независимы друг от друга:

+ [«Математика, биты, магия и немного ненормального программирования на C»](https://habr.com/ru/companies/timeweb/articles/935728/)
+ [«Фокусы, хаки, магия и прочее ненормальное программирование на C»](https://habr.com/ru/companies/timeweb/articles/967678/)
+ [«Тёмная сторона Си: трюки, хаки, магия и алгоритмы»](https://habr.com/ru/companies/timeweb/articles/970910/)

---

Вот и наступила 4 часть! В этой статье мы погружаемся в менее известные хаки, фаны, алгоритмы на нашем любимом живом C!

# Бесконечный цикл без `while`
Простой, но интересный трюк:

```cpp
#include <stdio.h>

void infinite_loop(int n) {
    printf("%d\n", n);
    infinite_loop(n + 1);
}

int main() {
    infinite_loop(1);
    return 0;
}
```

Классическое переполнение стека через рекурсию. Рекурсия без базового случая это гарантированное переполнение стека.

# ГПСЧ SplitMix64
Ещё один качественный и быстрый ГПСЧ, часто используемый для инициализации состояния других генераторов (например, того же xoshiro256pp).

```cpp
uint64_t splitmix64(uint64_t *x) {
    *x += 0x9e3779b97f4a7c15;
    uint64_t z = *x;
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    return z ^ (z >> 31);
}
```

Эта функция принимает указатель на внутреннее состояние генератора. При каждом вызове состояние увеличивается на константу `0x9e3779b97f4a7c15`. Затем выполняется три этапа преобразования этого состояния:

1. Сдвиг вправо на 30 бит и XOR с исходным значением, после чего результат умножается на константу `0xbf58476d1ce4e5b9`.
2. Сдвиг вправо на 27 бит и XOR с текущим значением, затем умножение на константу `0x94d049bb133111eb`
3. Сдвиг вправо на 31 бит и операция XOR с полученным значением. Результат этой операции и есть псевдослучайное число

30, 27 и 31 бит были подобраны экспериментальным путем, также как и константы. Алгоритм детерминированный - при одинаковом начальном состоянии выдает одинаковые последовательности.

# Счетчик Морриса
Счётчик Морриса — это вероятностный алгоритм для приблизительного подсчёта большого количества событий, используя при этом значительно меньше памяти, чем точные счётчики. Вместо хранения точного значения счётчика, он хранит его логарифмическую аппроксимацию.

```c
uint8_t morris_counter = 0;
void morris_increment() {
    if (rand() < (RAND_MAX / (1 << morris_counter))) {
        morris_counter++;
    }
}
uint32_t morris_estimate() {
    return (1 << morris_counter) - 1;
}
```

Алгоритм увеличивает значение счётчика не при каждом событии, а с вероятностью, которая уменьшается по мере роста значения счётчика. Это позволяет представлять очень большие числа, используя всего несколько бит.

Сама функция очень экономиная по памяти, 8-битный счётчик может представлять числа до 2⁸-1 = 255, но алгоритм позволяет оценивать гораздо большие значения (до 2²⁵⁵-1 в теории).

Ну и также он неточен и зависит от генератора случайных (или псевдослучайных) чисел.

Вы можете реализовать этот алгоритм, используя ГПСЧ которые мы писали раннее в статьях!

# Заключение

Спасибо за прочтение статьи! Я надеюсь, вы узнали что‑то новенькое, или может, какой‑нибудь трюк натолкнул вас на другой интересный алгоритм. Если нашли нюанс в самой статье — пишите в комментарии.

Если вам понравился изложенный материал, могу предложить вам подписаться на [мой блог в телеграме](https://t.me/hex_warehouse). Если, конечно, вам статья понравилась и вы хотите видеть чуть больше.

Примеры работы кода вы можете увидеть в [моем репозитории The Art Of Fun C](https://github.com/alexeev-prog/theartoffun_c).

